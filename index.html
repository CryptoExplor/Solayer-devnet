<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solayer Devnet ‚Äî Faucet Bot & Random Sender</title>
    <!-- Solana Web3 library -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <!-- SPL Token (IIFE build exposes global `splToken`) -->
    <!-- Buffer polyfill (needed for SPL Token) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/buffer/6.0.3/buffer.min.js"></script>
    <script>
    window.Buffer = buffer.Buffer;
    </script>
    <!-- SPL Token -->
    <!-- Downgraded to a version compatible with the Token class for IIFE build -->
    <script src="https://unpkg.com/@solana/spl-token@0.3.8/lib/index.iife.js"></script>
    <script>
    // This variable is now accessible by all functions in this script block
    const splToken = window.splToken;
    </script>
    <style>
        :root{--bg:#0b1020;--panel:#111831;--muted:#6b7a99;--text:#e8edf7;--accent:#7aa2ff;--ok:#27d980;--warn:#ffd166;--err:#ff6b6b}
        *{box-sizing:border-box}
        body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
        .wrap{max-width:1100px;margin:20px auto;padding:16px}
        h1{font-size:20px;margin:0 0 12px}
        .tabs{display:flex;gap:8px;margin-bottom:12px}
        .tab{padding:8px 12px;border:1px solid #25315a;background:#0e1633;border-radius:10px;cursor:pointer;transition:background-color 0.3s, border-color 0.3s;}
        .tab.active{background:linear-gradient(135deg,#4169e1,#29c6ff);color:#001225;border:0}
        .card{background:linear-gradient(180deg,#121a36,#0e152b);border:1px solid #1f2745;border-radius:14px;padding:14px}
        textarea,input,button,select{width:100%;border-radius:10px;border:1px solid #20305e;background:#0c1430;color:var(--text);padding:10px;outline:none;}
        button{cursor:pointer;font-weight:700;transition:background-color 0.3s;}
        .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
        .muted{color:#9fb0d6}
        .pill{display:inline-block;margin-right:8px;margin-top:8px;padding:6px 10px;border-radius:999px;border:1px solid #29335a;background:#0d1533}
        .ok{border-color:#1e6f4f;color:#a9f3cd}
        .err{border-color:#7a2b2b;color:#ffb6b6}
        pre{height:360px;overflow:auto;background:#091130;border:1px solid #1a2349;border-radius:12px;padding:10px;white-space:pre-wrap}
        .hidden{display:none}
        #message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 300px;
            padding: 15px;
            background: #25315a;
            border: 1px solid #3c4c7b;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }
        #message-box.show {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #message-box p {
            margin: 0;
            font-weight: bold;
        }
        .connection-pill {
            margin-top: 12px;
            text-align: center;
            font-weight: bold;
            color: var(--err);
        }
        .connection-pill.connected {
            color: var(--ok);
        }
        /* Style for disabled buttons */
        button:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Solayer Devnet ‚Äî Faucet Bot & Random Sender</h1>
        <div class="tabs">
            <button class="tab active" id="tab-faucet">Faucet Auto‚ÄëClaimer</button>
            <button class="tab" id="tab-sender">Auto Sender (SOL & LAYER)</button>
        </div>

        <!-- Faucet Tab -->
        <section id="panel-faucet" class="card">
            <p class="muted">Runs indefinitely with random 1‚Äì5s delay across all addresses.</p>
            <div class="row">
                <div>
                    <label>RPC URL</label>
                    <input id="rpcFaucet" value="https://devnet-rpc.solayer.org" />
                </div>
                <div>
                    <label>Amount per airdrop (SOL)</label>
                    <input id="amtFaucet" type="number" step="0.001" value="1" />
                </div>
            </div>
            <label style="margin-top:8px">Wallet addresses (one per line, base58)</label>
            <textarea id="addrsFaucet" rows="6" placeholder="9x3H...\nC4nDy...\n..."></textarea>
            <div class="row" style="margin-top:8px">
                <button id="startFaucet">‚ñ∂ Start Faucet Loop</button>
                <button id="stopFaucet" disabled>‚èπ Stop</button>
            </div>
            <div>
                <span class="pill" id="faucetTotal">Total: 0</span>
                <span class="pill ok" id="faucetOk">Success: 0</span>
                <span class="pill err" id="faucetErr">Errors: 0</span>
            </div>
            <pre id="logFaucet"></pre>
        </section>

        <!-- Sender Tab -->
        <section id="panel-sender" class="card hidden">
            <p class="muted">Sends to a <b>random new address</b> every 1‚Äì5s. Ranges: SOL 0.001‚Äì0.05 ¬∑ LAYER 0.0001‚Äì0.005</p>
            <div class="row">
                <div>
                    <label>RPC URL</label>
                    <input id="rpcSender" value="https://devnet-rpc.solayer.org" />
                </div>
                <div>
                    <label>LAYER mint</label>
                    <input id="layerMint" value="LAYER4xPpTCb3QL8S9u41EAhAX7mhBn8Q6xMTwY2Yzc" />
                </div>
            </div>
            <div style="margin-top:8px">
                <label>Send Mode</label>
                <select id="modeSender">
                    <option value="both">SOL and LAYER (Random)</option>
                    <option value="sol">Only SOL</option>
                    <option value="layer">Only LAYER</option>
                </select>
            </div>
            <div style="margin-top:8px">
                <button id="connectWalletBtn">üîó Connect Wallet</button>
                <div id="connectionStatus" class="connection-pill">Not Connected</div>
            </div>
            <label style="margin-top:8px">Connected Address</label>
            <input id="connectedAddress" readonly style="color: var(--ok);"/>
            <div class="row" style="margin-top:8px">
                <button id="startSender" disabled>‚ñ∂ Start Auto Sender</button>
                <button id="stopSender" disabled>‚èπ Stop</button>
            </div>
            <div>
                <span class="pill" id="senderSent">Sent: 0</span>
                <span class="pill ok" id="senderOk">OK: 0</span>
                <span class="pill err" id="senderErr">Err: 0</span>
            </div>
            <pre id="logSender"></pre>
        </section>
        
    </div>

    <!-- Custom Message Box -->
    <div id="message-box" class="card">
        <p id="message-text"></p>
    </div>

    <script>
        // Helper function to get an element by ID
        const $ = (id) => document.getElementById(id);

        // Helper function for a non-blocking delay
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        // Helper function for a random number within a range
        const rand = (min, max) => Math.random() * (max - min) + min;

        // Custom message box to replace alert()
        function showMessage(msg) {
            const msgBox = $('message-box');
            const msgText = $('message-text');
            msgText.textContent = msg;
            msgBox.classList.add('show');
            setTimeout(() => {
                msgBox.classList.remove('show');
            }, 4000);
        }

        // Tab functionality
        const tabF = $("tab-faucet"), tabS = $("tab-sender");
        const panelF = $("panel-faucet"), panelS = $("panel-sender");
        tabF.onclick = () => { tabF.classList.add('active'); tabS.classList.remove('active'); panelF.classList.remove('hidden'); panelS.classList.add('hidden'); };
        tabS.onclick = () => { tabS.classList.add('active'); tabF.classList.remove('active'); panelS.classList.remove('hidden'); panelF.classList.add('hidden'); };


        // ===== Faucet Auto‚ÄëClaimer Logic =====
        let faucetRun = false;
        let faucetStats = { total: 0, ok: 0, err: 0 };
        const startFaucetBtn = $("startFaucet");
        const stopFaucetBtn = $("stopFaucet");

        // Logs messages to the Faucet section
        function fLog(msg) {
            const ts = new Date().toLocaleTimeString();
            const logElement = $("logFaucet");
            logElement.textContent += `[${ts}] ${msg}\n`;
            logElement.scrollTop = logElement.scrollHeight; // Auto-scroll to the bottom
        }

        // Updates the Faucet stats display
        function updateF() {
            $("faucetTotal").textContent = `Total: ${faucetStats.total}`;
            $("faucetOk").textContent = `Success: ${faucetStats.ok}`;
            $("faucetErr").textContent = `Errors: ${faucetStats.err}`;
        }

        // The main faucet loop
        async function faucetLoop() {
            const rpc = $("rpcFaucet").value.trim();
            const amountSol = parseFloat($("amtFaucet").value || '0.1');
            const lamports = Math.floor(amountSol * 1e9);
            const addresses = $("addrsFaucet").value.split(/\n+/).map(s => s.trim()).filter(Boolean);

            if (!addresses.length) {
                showMessage('Please enter at least one address for the Faucet.');
                return;
            }

            faucetRun = true;
            startFaucetBtn.disabled = true;
            stopFaucetBtn.disabled = false;
            fLog(`Connecting to RPC ‚Üí ${rpc}`);
            const connection = new solanaWeb3.Connection(rpc, { commitment: 'confirmed' });

            while (faucetRun) {
                // Select a random address from the list
                const addr = addresses[Math.floor(Math.random() * addresses.length)];
                
                try {
                    faucetStats.total++;
                    updateF();
                    const pk = new solanaWeb3.PublicKey(addr);
                    fLog(`Requesting airdrop of ${amountSol} SOL for address ${addr}`);
                    const sig = await connection.requestAirdrop(pk, lamports);
                    fLog(`Airdrop TX ‚Üí ${sig}`);

                    // Wait for transaction confirmation
                    fLog(`Waiting for confirmation...`);
                    await connection.confirmTransaction(sig, 'confirmed');
                    faucetStats.ok++;
                    updateF();
                    fLog(`‚úÖ Airdrop confirmed!`);
                } catch (e) {
                    faucetStats.err++;
                    updateF();
                    fLog(`‚ùå Error on address ${addr}: ${e?.message || e}`);
                }
                // Wait for a random delay before the next airdrop
                const delay = Math.floor(rand(1000, 5000));
                fLog(`‚è≥ Waiting for ${(delay / 1000).toFixed(2)}s`);
                if (faucetRun) {
                    await sleep(delay);
                }
            }
            fLog('üõë Faucet loop stopped.');
            startFaucetBtn.disabled = false;
            stopFaucetBtn.disabled = true;
        }

        startFaucetBtn.onclick = () => { if (!faucetRun) faucetLoop(); };
        stopFaucetBtn.onclick = () => { faucetRun = false; };

        // ===== Auto Sender (SOL & LAYER) Logic =====
        let senderRun = false;
        let senderStats = { sent: 0, ok: 0, err: 0 };
        let walletProvider = null;
        const connectWalletBtn = $("connectWalletBtn");
        const startSenderBtn = $("startSender");
        const stopSenderBtn = $("stopSender");

        // Logs messages to the Sender section
        function sLog(msg) {
            const ts = new Date().toLocaleTimeString();
            const logElement = $("logSender");
            logElement.textContent += `[${ts}] ${msg}\n`;
            logElement.scrollTop = logElement.scrollHeight; // Auto-scroll to the bottom
        }

        // Updates the Sender stats display
        function updateS() {
            $("senderSent").textContent = `Sent: ${senderStats.sent}`;
            $("senderOk").textContent = `OK: ${senderStats.ok}`;
            $("senderErr").textContent = `Err: ${senderStats.err}`;
        }
        
        // Updates wallet connection status
        function updateConnectionStatus(isConnected, publicKey = null) {
            const statusEl = $('connectionStatus');
            const addressEl = $('connectedAddress');
            if (isConnected) {
                statusEl.textContent = 'Connected';
                statusEl.classList.add('connected');
                addressEl.value = publicKey.toBase58();
                startSenderBtn.disabled = false;
            } else {
                statusEl.textContent = 'Not Connected';
                statusEl.classList.remove('connected');
                addressEl.value = '';
                startSenderBtn.disabled = true;
                stopSenderBtn.disabled = true;
            }
        }
        
        // Function to connect to a browser wallet
        async function connectWallet() {
            if ("solana" in window) {
                try {
                    const solana = window.solana;
                    const response = await solana.connect();
                    walletProvider = solana;
                    updateConnectionStatus(true, response.publicKey);
                    sLog(`Connected to wallet: ${response.publicKey.toBase58()}`);
                } catch (e) {
                    showMessage(`Error connecting to wallet: ${e?.message || e}`);
                    sLog(`‚ùå Error connecting to wallet: ${e?.message || e}`);
                }
            } else {
                showMessage("Solana wallet not found. Please install Phantom or Solflare.");
                sLog("‚ùå Solana wallet not found. Please install Phantom or Solflare.");
            }
        }

        // ===== SOL transfer =====
        async function sendRandomSOL(connection, wallet) {
            const recipient = solanaWeb3.Keypair.generate().publicKey;
            const amount = rand(0.001, 0.05);
            const tx = new solanaWeb3.Transaction().add(
                solanaWeb3.SystemProgram.transfer({
                    fromPubkey: wallet.publicKey,
                    toPubkey: recipient,
                    lamports: Math.floor(amount * 1e9)
                })
            );
            tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;
            tx.feePayer = wallet.publicKey;
            const { signature } = await wallet.signAndSendTransaction(tx);
            sLog(`üì§ Sent ${amount.toFixed(6)} SOL ‚Üí ${recipient.toBase58()} | TX: ${signature}`);
            return signature;
        }

        // ===== LAYER transfer (fixed) =====
        async function sendRandomLAYER(connection, wallet, mintStr) {
            const recipient = solanaWeb3.Keypair.generate().publicKey;
            const mintPublicKey = new solanaWeb3.PublicKey(mintStr);

            // Use the older Token class API which is available in the IIFE build
            const token = new splToken.Token(
                connection,
                mintPublicKey,
                splToken.TOKEN_PROGRAM_ID,
                wallet.publicKey
            );
            
            // Get or create the associated token accounts for sender and recipient
            const fromAta = await token.getOrCreateAssociatedAccountInfo(wallet.publicKey);
            const toAta = await token.getOrCreateAssociatedAccountInfo(recipient);

            // Amount in smallest unit (assume 9 decimals)
            const decimals = fromAta.amount.decimals || 9;
            const amount = Math.floor(rand(0.0001, 0.005) * Math.pow(10, decimals));

            // Create the transfer instruction
            const transaction = new solanaWeb3.Transaction().add(
                splToken.Token.createTransferInstruction(
                    splToken.TOKEN_PROGRAM_ID,
                    fromAta.address,
                    toAta.address,
                    wallet.publicKey,
                    [],
                    amount
                )
            );
            
            // Set fee payer and blockhash
            transaction.feePayer = wallet.publicKey;
            transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

            // Sign and send the transaction
            const { signature } = await wallet.signAndSendTransaction(transaction);

            sLog(`ü™ô Sent ${(amount / Math.pow(10, decimals)).toFixed(6)} LAYER ‚Üí ${recipient.toBase58()} | TX: ${signature}`);
            return signature;
        }

        // ===== Sender loop =====
        async function senderLoop() {
            const rpc = $("rpcSender").value.trim();
            const mode = $("modeSender").value;
            const mint = $("layerMint").value.trim();

            if (!walletProvider || !walletProvider.publicKey) {
                showMessage('Please connect your wallet first.');
                return;
            }

            const connection = new solanaWeb3.Connection(rpc, { commitment: 'confirmed' });

            sLog(`Connected wallet: ${walletProvider.publicKey.toBase58()}`);

            senderRun = true;
            startSenderBtn.disabled = true;
            stopSenderBtn.disabled = false;

            while (senderRun) {
                try {
                    const balance = await connection.getBalance(walletProvider.publicKey);
                    const balanceSol = balance / solanaWeb3.LAMPORTS_PER_SOL;
                    sLog(`Current balance: ${balanceSol.toFixed(4)} SOL`);

                    if (balanceSol < 0.001) {
                        sLog('‚ö†Ô∏è Insufficient SOL balance. Stopping sender.');
                        senderRun = false;
                        break;
                    }

                    senderStats.sent++;
                    updateS();

                    const choice = mode === 'both' ? (Math.random() < 0.5 ? 'sol' : 'layer') : mode;
                    if (choice === 'sol') {
                        await sendRandomSOL(connection, walletProvider);
                    } else {
                        await sendRandomLAYER(connection, walletProvider, mint);
                    }

                    senderStats.ok++;
                    updateS();
                } catch (e) {
                    senderStats.err++;
                    updateS();
                    sLog(`‚ùå Send error: ${e?.message || e}`);
                    console.error(e);
                }

                const delay = Math.floor(rand(1000, 5000));
                sLog(`‚è≥ Waiting for ${(delay / 1000).toFixed(2)}s`);
                if (senderRun) await sleep(delay);
            }

            sLog('üõë Sender loop stopped.');
            startSenderBtn.disabled = false;
            stopSenderBtn.disabled = true;
        }

        connectWalletBtn.onclick = connectWallet;
        startSenderBtn.onclick = () => { if (!senderRun) senderLoop(); };
        stopSenderBtn.onclick = () => { senderRun = false; };

        if ("solana" in window) {
            window.solana.on('disconnect', () => {
                sLog("Wallet disconnected.");
                senderRun = false;
                walletProvider = null;
                updateConnectionStatus(false);
            });
        }
    </script>
</body>
</html>
