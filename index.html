<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solayer Devnet ‚Äî Faucet</title>
    <!-- Solana Web3 library -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <!-- SPL Token library -->
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.js"></script>
    <!-- Buffer polyfill -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/buffer/6.0.3/buffer.min.js"></script>
    <script>
        window.Buffer = buffer.Buffer;
    </script>
    <style>
        :root{--bg:#0b1020;--panel:#111831;--muted:#6b7a99;--text:#e8edf7;--accent:#7aa2ff;--success:#27d980;--warn:#ffd166;--fail:#ff6b6b; --log-bg:#091130;}
        .light-theme{--bg:#f2f5f9;--panel:#fff;--muted:#6b7a99;--text:#111831;--accent:#246ce0;--success:#1f805a;--warn:#d9981e;--fail:#cc3434; --log-bg:#e9ecef;}
        *{box-sizing:border-box}
        body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial; transition: background-color 0.3s, color 0.3s;}
        .wrap{max-width:1100px;margin:20px auto;padding:16px}
        h1{font-size:20px;margin:0 0 12px}
        .card{background:var(--panel);border:1px solid #1f2745;border-radius:14px;padding:14px; transition: background-color 0.3s, border-color 0.3s;}
        .light-theme .card {border-color:#e1e5eb}
        textarea,input,button,select{width:100%;border-radius:10px;border:1px solid #20305e;background:var(--bg);color:var(--text);padding:10px;outline:none; transition: background-color 0.3s, border-color 0.3s, color 0.3s;}
        .light-theme textarea, .light-theme input, .light-theme select {background-color: #e9ecef;}
        button{cursor:pointer;font-weight:700;transition:background-color 0.3s, transform 0.1s;}
        button:hover:not(:disabled) {
            background-color: #29335a;
        }
        .light-theme button:hover:not(:disabled) {
             background-color: #ddd;
        }
        .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
        .muted{color:var(--muted)}
        .pill{display:inline-block;margin-right:8px;margin-top:8px;padding:6px 10px;border-radius:999px;border:1px solid #29335a;background:#0d1533;transition:background-color 0.3s;}
        .light-theme .pill {background-color:#e6e6e6; border-color: #ccc; color: #555;}
        .pill.active {
            box-shadow: 0 0 5px var(--accent);
            border-color: var(--accent);
        }
        .pill.cooldown {
            border-color: var(--warn);
            color: var(--warn);
        }
        .ok{border-color:#1e6f4f;color:#a9f3cd}
        .light-theme .ok {border-color:#65b38d; color: #378a5b;}
        .err{border-color:#7a2b2b;color:#ffb6b6}
        .light-theme .err {border-color:#ab5a5a; color: #a82e2e;}
        pre{height:360px;overflow:auto;background:var(--log-bg);border:1px solid #1a2349;border-radius:12px;padding:10px;white-space:pre-wrap; min-height: 150px; transition: background-color 0.3s, border-color 0.3s;}
        .light-theme pre {border-color:#ddd;}
        pre a {
            color: var(--accent);
            text-decoration: underline;
        }
        pre a:hover {
            text-decoration: none;
        }
        .hidden{display:none}
        #message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 300px;
            padding: 15px;
            background: #25315a;
            border: 1px solid #3c4c7b;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        .light-theme #message-box {
            background: #e9ecef;
            border-color: #ddd;
            color: #111831;
        }
        #message-box.show {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #message-box p {
            margin: 0;
            font-weight: bold;
        }
        button:disabled, input:disabled, textarea:disabled, select:disabled {
            background-color: #1a1a1a;
            color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .light-theme button:disabled, .light-theme input:disabled, .light-theme textarea:disabled, .light-theme select:disabled {
            background-color: #f1f1f1;
            color: #bbb;
        }
        .balance-pills {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .checkbox-label input {
            width: auto;
        }
        .section-separator {
            border: 0;
            height: 1px;
            background: #2a345a;
            margin: 20px 0;
        }
        .light-theme .section-separator {background-color: #ddd;}
        .faucet-link {
            text-align: center;
            margin-bottom: 12px;
        }
        .faucet-link a {
            color: var(--accent);
            text-decoration: underline;
            font-weight: bold;
        }
        .faucet-link a:hover {
            text-decoration: none;
        }
        .status-and-timer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
        }
        #session-timer {
            font-weight: bold;
            color: var(--accent);
            min-width: 80px;
            text-align: right;
        }
        #sessionSummary {
            text-align: center;
            flex-grow: 1;
        }
        #errorAnalytics {
            margin-top: 12px;
            background: var(--log-bg);
            border: 1px solid #1a2349;
            border-radius: 12px;
            padding: 10px;
            min-height: 50px;
        }
        .light-theme #errorAnalytics {
            border-color: #ddd;
        }
        #errorAnalytics h3 {
            margin: 0 0 8px;
            font-size: 16px;
        }
        #errorAnalytics ul {
            margin: 0;
            padding: 0;
            list-style: none;
        }
        .guide-section {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #2a345a;
        }
        .light-theme .guide-section {
            border-top-color: #ddd;
        }
        
        /* Mobile-first adjustments for better responsiveness */
        @media (max-width: 600px) {
            .wrap {
                margin: 10px;
                padding: 10px;
            }
            .row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Solayer Devnet ‚Äî Faucet Auto‚ÄëClaimer</h1>
        
        <!-- Faucet Tab -->
        <section id="panel-faucet" class="card">
            <div class="faucet-link">
                Official Faucet: <a href="https://explorer.solayer.org/faucet" target="_blank">https://explorer.solayer.org/faucet</a>
            </div>
            <p class="muted">Runs indefinitely with a random delay. Skips wallets with sufficient balance.</p>
            <div style="margin-bottom:8px">
                <label>Claim Mode</label>
                <select id="faucetMode">
                    <option value="indefinitely">Indefinitely</option>
                    <option value="total" selected>Number of claims (total)</option>
                    <option value="per-wallet">Number of claims (per wallet)</option>
                </select>
            </div>
            <div id="faucet-limit-container" style="margin-top:8px">
                <label>Number of Claims</label>
                <input id="faucetClaimLimit" type="number" min="1" value="10"/>
            </div>
            <div class="row" style="margin-top:8px">
                <div>
                    <label>RPC URL(s) (comma-separated for failover)</label>
                    <input id="rpcFaucet" value="https://devnet-rpc.solayer.org" />
                </div>
                <div>
                    <label>Amount per airdrop (SOL)</label>
                    <input id="amtFaucet" type="number" step="0.001" value="1" />
                </div>
            </div>
            <div style="margin-top:8px">
                <label>Proxy URL(s) (optional, one per line)</label>
                <textarea id="proxyUrls" rows="3" placeholder="http://user:pass@127.0.0.1:8080\nhttp://another.proxy.com:8080\n..."></textarea>
            </div>
            <div class="row" style="margin-top:8px">
                <div>
                    <label>Min Delay (ms)</label>
                    <input id="minDelay" type="number" min="1000" value="1000" />
                </div>
                <div>
                    <label>Max Delay (ms)</label>
                    <input id="maxDelay" type="number" min="1000" value="5000" />
                </div>
            </div>
            <div class="row" style="margin-top:8px">
                <div>
                    <label>Skip If Balance > (SOL)</label>
                    <input id="skipBalance" type="number" step="0.1" value="500" />
                </div>
                <div>
                    <label>Cooldown per wallet (sec)</label>
                    <input id="cooldown" type="number" min="1" value="60" />
                </div>
            </div>
            <label style="margin-top:8px">Wallet addresses (one per line, base58)</label>
            <textarea id="addrsFaucet" rows="6" placeholder="9x3H...\nC4nDy...\n..."></textarea>
            <div id="wallet-status-container" style="margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px;">
                <!-- Wallet status pills will be dynamically inserted here -->
            </div>
            <div class="row" style="margin-top:8px">
                <button id="startFaucet">‚ñ∂ Start Faucet Loop</button>
                <button id="stopFaucet" disabled>‚èπ Stop</button>
            </div>
            <div class="row" style="margin-top:8px">
                <button id="clearFaucetLog">üßπ Clear Log & Stats</button>
                <button id="downloadLog">‚¨áÔ∏è Download Log</button>
            </div>
            <div class="row" style="margin-top:8px">
                <button id="resetSession">‚ôªÔ∏è Reset Session Counts</button>
                <button id="downloadClaims">‚¨áÔ∏è Export Claims JSON</button>
            </div>
            <div class="status-and-timer">
                <div class="balance-pills">
                    <span class="pill" id="faucetTotal">Total: 0</span>
                    <span class="pill status-success" id="faucetSuccess">Success: 0</span>
                    <span class="pill status-fail" id="faucetFail">Errors: 0</span>
                </div>
                <span id="session-timer">‚è± 0s</span>
            </div>
            <span class="pill" id="sessionSummary"></span>
            <div class="row" style="margin-top:8px">
                <label class="checkbox-label">
                    <input type="checkbox" id="pauseScroll"> Pause auto-scroll
                </label>
                <button id="themeToggle" style="width: auto;">üåô Toggle Theme</button>
            </div>
            
            <h2 style="margin-top: 20px;">Error Analytics</h2>
            <div id="errorAnalytics" class="card">
                <h3>Breakdown of Airdrop Failures</h3>
                <ul id="errorList">
                    <!-- Error stats will be dynamically inserted here -->
                </ul>
            </div>
            
            <h2 style="margin-top: 20px;">Activity Log</h2>
            <pre id="logFaucet"></pre>
            <h2 style="margin-top: 20px;">Session History</h2>
            <pre id="session-history-log"></pre>
        </section>

        <!-- Guide Section -->
        <section class="guide-section">
            <h2>Guide for Using the Auto-Claimer</h2>
            <p>This application helps you automatically claim SOL from the Solayer Devnet Faucet across multiple wallets. It's designed to be resilient, with features like multi-RPC randomization, proxy support, and error analytics to give you a smooth experience.</p>

            <h3>How to Configure</h3>
            <p>
                To get started, simply follow these steps:
                <ul>
                    <li><strong>RPC URL(s):</strong> Enter one or more RPC endpoints, separated by a comma. The app will randomly select one for each claim attempt to balance the load.</li>
                    <li><strong>Proxy URL(s):</strong> If you are running into rate limits, you can enter one or more proxy URLs. The app will randomly use a proxy for each request.</li>
                    <li><strong>Wallet addresses:</strong> Paste the list of wallet public keys, with one address on each new line.</li>
                    <li><strong>Amount & Delay:</strong> Set the amount of SOL to claim per airdrop and the minimum/maximum delay between each claim. The app will use a random delay within this range.</li>
                    <li><strong>Skip & Cooldown:</strong> Use the "Skip If Balance" field to prevent claiming on wallets that already have enough SOL. The "Cooldown" setting prevents the app from spamming a single wallet, ensuring your requests don't get throttled.</li>
                </ul>
            </p>

            <h3>Key Features</h3>
            <p>
                <ul>
                    <li><strong>Multi-RPC Randomization:</strong> The app automatically switches between the RPCs you provide, reducing the chance of a single endpoint getting rate-limited. If an RPC fails, it will attempt to use another.</li>
                    <li><strong>Error Analytics:</strong> The "Error Analytics" box gives you a real-time breakdown of the types of errors you're encountering, which is useful for debugging and understanding network issues.</li>
                    <li><strong>Session History & Export:</strong> The "Session History" log keeps a record of your past claiming sessions. You can also export a JSON file containing your total and session claims using the "Export Claims JSON" button.</li>
                </ul>
            </p>
            <p>
                For more details and to contribute to the project, visit the official GitHub repository:
                <a href="https://github.com/CryptoExplor/Solayer-devnet-faucet" target="_blank">https://github.com/CryptoExplor/Solayer-devnet-faucet</a>
            </p>
        </section>
    </div>
    
    <!-- Custom Message Box -->
    <div id="message-box" class="card hidden">
        <p id="message-text"></p>
    </div>
    
    <script>
        // Helper functions
        const $ = (id) => document.getElementById(id);
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const rand = (min, max) => Math.random() * (max - min) + min;

        // Global state variables
        let faucetRun = false;
        let faucetStats = { total: 0, success: 0, fail: 0, retries: {}, errors: {} };
        let claimsPerSession = {}; // Per-session counter
        let totalClaimsPerWallet = {}; // Total persistent counter
        let rpcUrls = [];
        let proxyUrls = []; // New array for proxy URLs

        // Timer variables
        let sessionTimerInterval = null;
        let sessionStartTime = 0;
        let walletCooldowns = {};
        
        // Session history variables
        let sessionHistory = [];
        const SESSION_HISTORY_KEY = "faucetSessionHistory";

        // Helper function to create a clickable explorer link
        function createExplorerLink(signature) {
            const explorerBaseUrl = "https://explorer.solayer.org";
            return `<a href="${explorerBaseUrl}/tx/${signature}" target="_blank">${signature.substring(0, 8)}...</a>`;
        }
        
        // Custom message box
        function showMessage(msg) {
            const msgBox = $('message-box');
            const msgText = $('message-text');
            msgText.textContent = msg;
            msgBox.classList.remove('hidden');
            msgBox.classList.add('show');
            setTimeout(() => {
                msgBox.classList.add('hidden');
                msgBox.classList.remove('show');
            }, 4000);
        }
        
        window.onload = function() {
            // Restore persistent total stats and session history from localStorage on page load
            const storedTotalClaims = localStorage.getItem("totalClaimsPerWallet");
            if (storedTotalClaims) {
                totalClaimsPerWallet = JSON.parse(storedTotalClaims);
            }
            const storedSessionHistory = localStorage.getItem(SESSION_HISTORY_KEY);
            if (storedSessionHistory) {
                sessionHistory = JSON.parse(storedSessionHistory);
            }
            
            updateFaucetStats();
            setupEventListeners();
            handleFaucetModeChange(); // Initialize the faucet UI on page load
            renderSessionHistory(); // Render the history log on load
        };

        // Setup all event listeners
        function setupEventListeners() {
            // Faucet Buttons
            const startFaucetBtn = $("startFaucet");
            const stopFaucetBtn = $("stopFaucet");
            const clearFaucetBtn = $("clearFaucetLog");
            const downloadLogBtn = $("downloadLog");
            const downloadClaimsBtn = $("downloadClaims");
            const faucetModeSelect = $("faucetMode");
            const themeToggleBtn = $("themeToggle");
            const resetSessionBtn = $("resetSession");

            // Add handler for addresses textarea to create pills on input
            const addrsFaucetTextarea = $("addrsFaucet");
            addrsFaucetTextarea.oninput = () => {
                const addresses = addrsFaucetTextarea.value.split(/\n+/).map(s => s.trim()).filter(Boolean);
                createWalletStatusPills(addresses);
            };

            startFaucetBtn.onclick = () => {
                const addresses = addrsFaucetTextarea.value.split(/\n+/).map(s => s.trim()).filter(Boolean);
                if (!faucetRun) faucetLoop(addresses);
            };
            stopFaucetBtn.onclick = () => { 
                faucetRun = false; 
                stopFaucetBtn.textContent = 'Stopping...';
                stopFaucetBtn.disabled = true;
                clearInterval(sessionTimerInterval); // Stop the session timer
            };
            clearFaucetBtn.onclick = () => { 
                $("logFaucet").innerHTML = ''; 
                // Clear all stats, including the persistent ones
                localStorage.removeItem("faucetStats");
                localStorage.removeItem("totalClaimsPerWallet");
                localStorage.removeItem(SESSION_HISTORY_KEY);
                faucetStats = { total: 0, success: 0, fail: 0, retries: {}, errors: {} };
                totalClaimsPerWallet = {};
                claimsPerSession = {};
                walletCooldowns = {}; // Reset cooldowns
                sessionHistory = []; // Clear session history
                updateFaucetStats();
                renderErrorAnalytics(); // Clear error analytics
                const addresses = addrsFaucetTextarea.value.split(/\n+/).map(s => s.trim()).filter(Boolean);
                createWalletStatusPills(addresses);
                renderSessionHistory();
            };
            downloadLogBtn.onclick = downloadLog;
            downloadClaimsBtn.onclick = downloadClaims;
            faucetModeSelect.onchange = handleFaucetModeChange;
            themeToggleBtn.onclick = toggleTheme;
            
            // New reset session button handler
            resetSessionBtn.onclick = () => {
                claimsPerSession = {}; // Reset the session counter
                walletCooldowns = {}; // Reset cooldowns
                faucetStats.success = 0; // Reset session success count
                faucetStats.fail = 0; // Reset session error count
                faucetStats.total = 0; // Reset session total count
                faucetStats.errors = {}; // Reset error analytics
                const addresses = $("addrsFaucet").value.split(/\n+/).map(s => s.trim()).filter(Boolean);
                createWalletStatusPills(addresses); // Re-render pills
                fLog("‚ôªÔ∏è Session counts reset.");
                updateFaucetStats();
                renderErrorAnalytics();
            };
        }

        // Handles the UI change for different faucet claim modes
        function handleFaucetModeChange() {
            const mode = $("faucetMode").value;
            const limitContainer = $('faucet-limit-container');
            if (mode === 'indefinitely') {
                limitContainer.classList.add('hidden');
            } else {
                limitContainer.classList.remove('hidden');
            }
            // Update pills when mode changes
            const addresses = $("addrsFaucet").value.split(/\n+/).map(s => s.trim()).filter(Boolean);
            createWalletStatusPills(addresses);
        }

        // ===== Theme Toggle Logic =====
        function toggleTheme() {
            const body = document.body;
            const themeToggleBtn = $("themeToggle");
            body.classList.toggle('light-theme');
            if (body.classList.contains('light-theme')) {
                themeToggleBtn.textContent = '‚òÄÔ∏è Toggle Theme';
            } else {
                themeToggleBtn.textContent = 'üåô Toggle Theme';
            }
        }

        // ===== New function to download the log file =====
        function downloadLog() {
            const logContent = $('logFaucet').innerText.replace(/<br>/g, '\n').replace(/\[.*?\]\s/g, ''); // Clean up HTML and timestamps
            if (!logContent) {
                showMessage("Log is empty, nothing to download.");
                return;
            }
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `faucet-log-${new Date().toISOString()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ===== New function to download claims data as JSON =====
        function downloadClaims() {
            const data = {
                totals: totalClaimsPerWallet,
                session: claimsPerSession,
                timestamp: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `claims-${new Date().toISOString()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ===== Session History Logic =====
        function saveSessionHistory() {
            const newSession = {
                timestamp: new Date().toLocaleString(),
                totalClaims: faucetStats.total,
                success: faucetStats.success,
                fail: faucetStats.fail,
                elapsedTime: Date.now() - sessionStartTime,
                walletClaims: JSON.parse(JSON.stringify(claimsPerSession)) // Deep copy
            };
            sessionHistory.unshift(newSession); // Add to the beginning of the array
            localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(sessionHistory));
            renderSessionHistory();
        }
        
        function renderSessionHistory() {
            const historyLog = $("session-history-log");
            if (sessionHistory.length === 0) {
                historyLog.textContent = 'No past sessions found.';
                return;
            }
            
            let logText = '';
            sessionHistory.forEach((session, index) => {
                logText += `--- Session #${sessionHistory.length - index} (${session.timestamp}) ---\n`;
                logText += `  Total Claims: ${session.totalClaims}, Success: ${session.success}, Errors: ${session.fail}\n`;
                logText += `  Duration: ${formatTime(session.elapsedTime)}\n`;
                for (const [addr, claims] of Object.entries(session.walletClaims)) {
                    logText += `  - ${addr.substring(0, 0)}...: ${claims} claims\n`;
                }
                logText += '\n';
            });
            historyLog.textContent = logText;
        }
        
        // ===== Error Analytics Logic =====
        function incrementErrorCount(errorType) {
            faucetStats.errors[errorType] = (faucetStats.errors[errorType] || 0) + 1;
            renderErrorAnalytics();
        }

        function renderErrorAnalytics() {
            const errorList = $("errorList");
            errorList.innerHTML = ''; // Clear previous list
            
            const sortedErrors = Object.entries(faucetStats.errors).sort(([, a], [, b]) => b - a);
            
            if (sortedErrors.length === 0) {
                errorList.innerHTML = '<li>No errors recorded yet.</li>';
                return;
            }
            
            sortedErrors.forEach(([errorType, count]) => {
                const li = document.createElement('li');
                li.textContent = `${errorType}: ${count}`;
                errorList.appendChild(li);
            });
        }

        // ===== Timer Logic =====
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        }

        function updateSessionTimer() {
            const elapsedTime = Date.now() - sessionStartTime;
            const sessionClaims = Object.values(claimsPerSession).reduce((sum, count) => sum + count, 0);
            $("session-timer").textContent = `‚è± ${formatTime(elapsedTime)}`;
            $("sessionSummary").textContent = `Session Summary ‚Üí ‚úÖ ${sessionClaims} claims | ‚è± ${formatTime(elapsedTime)}`;
        }

        // ===== Per-Wallet Status Tracking UI Logic =====
        function createWalletStatusPills(addresses) {
            const container = $('wallet-status-container');
            container.innerHTML = ''; // Clear previous pills
            
            // Sort addresses based on status (cooldown first), then by claims
            const sortedAddresses = [...addresses].sort((a, b) => {
                const cooldownA = walletCooldowns[a] || 0;
                const cooldownB = walletCooldowns[b] || 0;
                const now = Date.now();
                
                const isCooldownA = cooldownA > now;
                const isCooldownB = cooldownB > now;
                
                if (isCooldownA && !isCooldownB) return -1;
                if (!isCooldownA && isCooldownB) return 1;
                
                // If both are on cooldown, sort by remaining time (descending)
                if (isCooldownA && isCooldownB) return cooldownB - cooldownA;
                
                // If neither are on cooldown, sort by claims (descending)
                const claimsA = totalClaimsPerWallet[a] || 0;
                const claimsB = totalClaimsPerWallet[b] || 0;
                return claimsB - claimsA;
            });

            sortedAddresses.forEach(addr => {
                const pill = document.createElement('span');
                pill.className = 'pill';
                pill.id = `status-${addr}`;
                
                const sessionClaims = claimsPerSession[addr] || 0;
                const totalClaims = totalClaimsPerWallet[addr] || 0;

                const textContent = `${addr.substring(0, 4)}... (‚úÖ${sessionClaims} | üì¶${totalClaims})`;

                pill.textContent = textContent;
                pill.title = `${addr} - ‚úÖ This session claims, üì¶ Lifetime claims`;
                container.appendChild(pill);
            });
        }

        function updateWalletStatusUI(address, status, message) {
            const pill = $(`status-${address}`);
            if (pill) {
                const sessionClaims = claimsPerSession[address] || 0;
                const totalClaims = totalClaimsPerWallet[address] || 0;
                const retries = faucetStats.retries[address] || 0;
                
                let textContent = `${address.substring(0, 4)}... (‚úÖ${sessionClaims} | üì¶${totalClaims})`;
                
                const cooldownEnd = walletCooldowns[address];
                if (cooldownEnd && cooldownEnd > Date.now()) {
                    const remaining = Math.max(0, cooldownEnd - Date.now());
                    const remainingSeconds = Math.ceil(remaining / 1000);
                    textContent += ` ‚è≥ ${remainingSeconds}s`;
                    pill.className = `pill cooldown`;
                } else {
                    if (status === 'ok') {
                        textContent += ` ‚úÖ`;
                        pill.className = `pill ok`;
                    } else if (status === 'err') {
                        textContent += ` ‚ùå`;
                        pill.className = `pill err`;
                        if (retries > 0) {
                            textContent += ` (retries: ${retries})`;
                        }
                    } else if (status === 'skipped') {
                        textContent += ` ‚è≠`;
                        pill.className = `pill`;
                    } else if (status === 'active') {
                        pill.className = `pill active`;
                    } else { // Idle state for cleanup
                        pill.className = `pill`;
                    }
                }
                
                pill.textContent = textContent;
                pill.title = `${address}: ${message}`;
            }
        }

        // ===== Faucet Auto‚ÄëClaimer Logic =====
        function fLog(msg) {
            const ts = new Date().toLocaleTimeString();
            const logElement = $("logFaucet");
            logElement.innerHTML += `[${ts}] ${msg}<br>`;
            
            if (logElement.childNodes.length > 1000) {
                logElement.removeChild(logElement.firstChild);
            }
            
            if (!$("pauseScroll").checked) {
                logElement.scrollTop = logElement.scrollHeight;
            }
        }
        
        function updateFaucetStats() {
            $("faucetTotal").textContent = `Total: ${Object.values(totalClaimsPerWallet).reduce((sum, count) => sum + count, 0)}`;
            $("faucetSuccess").textContent = `Success: ${faucetStats.success}`;
            $("faucetFail").textContent = `Errors: ${faucetStats.fail}`;
            localStorage.setItem("faucetStats", JSON.stringify(faucetStats));
            localStorage.setItem("totalClaimsPerWallet", JSON.stringify(totalClaimsPerWallet));
            updateSessionTimer();
        }

        function toggleFaucetInputs(disabled) {
            $("rpcFaucet").disabled = disabled;
            $("amtFaucet").disabled = disabled;
            $("addrsFaucet").disabled = disabled;
            $("faucetMode").disabled = disabled;
            $("faucetClaimLimit").disabled = disabled;
            $("minDelay").disabled = disabled;
            $("maxDelay").disabled = disabled;
            $("skipBalance").disabled = disabled;
            $("cooldown").disabled = disabled;
            $("startFaucet").disabled = disabled;
            $("stopFaucet").disabled = !disabled;
        }

        // Function to select a random RPC from the list
        function getRandomRpc() {
            const randomIndex = Math.floor(Math.random() * rpcUrls.length);
            return new solanaWeb3.Connection(rpcUrls[randomIndex], { commitment: 'confirmed' });
        }
        
        // Function to select a random proxy from the list
        function getRandomProxy() {
            if (proxyUrls.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * proxyUrls.length);
            return proxyUrls[randomIndex];
        }

        async function faucetLoop(addresses) {
            claimsPerSession = {};
            walletCooldowns = {};
            
            createWalletStatusPills(addresses);

            const rpcInput = $("rpcFaucet").value.trim();
            const proxyInput = $("proxyUrls").value.trim();
            const amountSol = parseFloat($("amtFaucet").value || '0.1');
            const minDelay = parseInt($("minDelay").value) || 1000;
            const maxDelay = parseInt($("maxDelay").value) || 5000;
            const skipBalance = parseFloat($("skipBalance").value) || 0;
            const cooldownSec = parseInt($("cooldown").value) || 60;
            
            rpcUrls = rpcInput.split(',').map(url => url.trim()).filter(Boolean);
            proxyUrls = proxyInput.split('\n').map(url => url.trim()).filter(Boolean); // Split by newline for proxies

            if (!rpcUrls.length) {
                showMessage('Please enter at least one RPC URL.');
                return;
            }

            const lamports = Math.floor(amountSol * 1e9);
            const skipLamports = Math.floor(skipBalance * 1e9);
            const faucetMode = $("faucetMode").value;
            const claimLimit = parseInt($("faucetClaimLimit").value);
            
            if (!addresses.length) {
                showMessage('Please enter at least one address for the Faucet.');
                return;
            }
            if ((faucetMode === 'total' || faucetMode === 'per-wallet') && (isNaN(claimLimit) || claimLimit <= 0)) {
                showMessage('Please enter a valid number of claims.');
                return;
            }
            
            faucetRun = true;
            toggleFaucetInputs(true);
            
            // Start the session timer
            sessionStartTime = Date.now();
            sessionTimerInterval = setInterval(updateSessionTimer, 1000);
            
            fLog(`Connecting to RPC(s) ‚Üí ${rpcUrls.join(', ')}`);
            if (proxyUrls.length > 0) {
                 fLog(`Using Proxies ‚Üí ${proxyUrls.join(', ')}`);
            }

            while (faucetRun) {
                const sessionClaims = Object.values(claimsPerSession).reduce((sum, count) => sum + count, 0);
                if (faucetMode === 'total' && sessionClaims >= claimLimit) {
                    fLog(`‚úÖ Total claim limit of ${claimLimit} reached. Stopping loop.`);
                    faucetRun = false;
                    break;
                }
                
                // Filter out addresses that are currently on cooldown
                const availableAddrs = addresses.filter(addr => !walletCooldowns[addr] || walletCooldowns[addr] <= Date.now());
                
                if (faucetMode === 'per-wallet' && availableAddrs.every(addr => (claimsPerSession[addr] || 0) >= claimLimit)) {
                    fLog('All available wallets have reached their claim limit. Stopping loop.');
                    faucetRun = false;
                    break;
                }
                
                if (availableAddrs.length === 0) {
                    fLog(`All wallets are on cooldown. Waiting for a wallet to become available.`);
                    await sleep(1000);
                    continue;
                }
                
                // Pick a random available address
                const randomIndex = Math.floor(Math.random() * availableAddrs.length);
                const addr = availableAddrs[randomIndex];
                
                let pk;
                try {
                    pk = new solanaWeb3.PublicKey(addr);
                } catch (e) {
                    fLog(`‚ùå Skipping invalid address: ${addr}. Error: ${e.message}`);
                    updateWalletStatusUI(addr, 'fail', `Invalid address.`);
                    await sleep(1000);
                    continue;
                }
                
                if (!claimsPerSession[addr]) claimsPerSession[addr] = 0;
                if (!totalClaimsPerWallet[addr]) totalClaimsPerWallet[addr] = 0;
                
                if (faucetMode === 'per-wallet' && claimsPerSession[addr] >= claimLimit) {
                    fLog(`Skipping ${addr}. Per-wallet limit of ${claimLimit} reached.`);
                    await sleep(1000);
                    continue;
                }
                
                updateWalletStatusUI(addr, 'active', `Attempting airdrop...`);

                try {
                    // Use a new connection for each balance check to spread load
                    const tempConnection = getRandomRpc();
                    const balance = await tempConnection.getBalance(pk);
                    if (balance > skipLamports) {
                        fLog(`‚è≠ Skipping ${addr}. Balance (${(balance / 1e9).toFixed(2)} SOL) is already sufficient.`);
                        updateWalletStatusUI(addr, 'skipped', `Balance sufficient: ${(balance / 1e9).toFixed(2)} SOL`);
                        await sleep(1000);
                        continue;
                    }
                } catch(e) {
                    fLog(`‚ö†Ô∏è Could not check balance for ${addr}: ${e?.message || e}. Proceeding with airdrop.`);
                    incrementErrorCount(categorizeError(e?.message || 'Unknown Error'));
                }
                
                // Update total stats for this run (will be reset for a new run)
                faucetStats.total++; 
                
                fLog(`Requesting airdrop of ${amountSol} SOL for address ${addr}`);
                
                let airdropSuccess = false;
                let retryCount = 0;
                const maxRetries = 5;
                while (retryCount < maxRetries && faucetRun) {
                    try {
                        const connection = getRandomRpc(); // Randomly pick an RPC for the airdrop
                        fLog(`Attempt ${retryCount + 1}: Using RPC ${connection._rpcEndpoint}`);
                        const sig = await connection.requestAirdrop(pk, lamports);
                        await connection.confirmTransaction(sig, 'confirmed');
                        fLog(`‚úÖ Airdrop confirmed! TX: ${createExplorerLink(sig)}`);
                        airdropSuccess = true;
                        break;
                    } catch (e) {
                        const delay = Math.min(Math.pow(2, retryCount) * 1000, 30000); // Exponential backoff
                        fLog(`‚ùå Error on attempt ${retryCount + 1}: ${e?.message || e}`);
                        
                        // Categorize and log the error
                        const errorMessage = e?.message || 'Unknown Error';
                        const errorCategory = categorizeError(errorMessage);
                        incrementErrorCount(errorCategory);
                        
                        if (retryCount < maxRetries - 1) {
                            fLog(`Retrying in ${delay / 1000}s...`);
                            await sleep(delay);
                        }

                        if (!faucetRun) {
                            break;
                        }
                        retryCount++;
                    }
                }
                
                if (airdropSuccess) {
                    faucetStats.success++;
                    
                    claimsPerSession[addr]++;
                    totalClaimsPerWallet[addr] = (totalClaimsPerWallet[addr] || 0) + 1;

                    // Set cooldown for this wallet using the new configurable value
                    walletCooldowns[addr] = Date.now() + cooldownSec * 1000;
                    
                    updateWalletStatusUI(addr, 'ok', `Airdrop successful.`);
                } else {
                    faucetStats.fail++;
                    fLog(`‚ùå Failed to airdrop to ${addr} after multiple retries.`);
                    updateWalletStatusUI(addr, 'err', `Airdrop failed.`);
                }
                
                updateFaucetStats();
                
                const [min, max] = minDelay > maxDelay ? [maxDelay, minDelay] : [minDelay, maxDelay];
                const delay = Math.floor(rand(min, max));
                fLog(`‚è≥ Waiting for ${(delay / 1000).toFixed(2)}s`);
                if (faucetRun) {
                    await sleep(delay);
                }
            }
            
            fLog('üõë Faucet loop stopped.');
            clearInterval(sessionTimerInterval); // Stop the session timer
            saveSessionHistory(); // Save the session history
            
            const perWalletLimitReached = faucetMode === 'per-wallet' && availableAddrs.every(addr => (claimsPerSession[addr] || 0) >= claimLimit);
            const totalLimitReached = faucetMode === 'total' && Object.values(claimsPerSession).reduce((sum, count) => sum + count, 0) >= claimLimit;
            const summaryMessage = (totalLimitReached || perWalletLimitReached)
                ? `Session complete: ${faucetStats.total} total, ${faucetStats.success} success, ${faucetStats.fail} errors.`
                : `Stopped manually: ${faucetStats.total} total, ${faucetStats.success} success, ${faucetStats.fail} errors.`;
            showMessage(summaryMessage);
            
            addresses.forEach(addr => updateWalletStatusUI(addr, 'idle', 'Idle'));
            
            toggleFaucetInputs(false);
            $('stopFaucet').textContent = '‚èπ Stop';
        }
        
        function categorizeError(errorMessage) {
            errorMessage = errorMessage.toLowerCase();
            if (errorMessage.includes('429 too many requests')) return '429 Too Many Requests';
            if (errorMessage.includes('http 502 bad gateway')) return '502 Bad Gateway';
            if (errorMessage.includes('service unavailable')) return 'Service Unavailable';
            if (errorMessage.includes('failed to get a response')) return 'Failed to Get Response';
            if (errorMessage.includes('airdrop request refused')) return 'Airdrop Refused';
            if (errorMessage.includes('invalid publickey')) return 'Invalid Address';
            if (errorMessage.includes('account not found')) return 'Account Too New';
            if (errorMessage.includes('transaction simulation failed')) return 'Simulation Failed';
            return 'Other/Unknown Error';
        }

        // A separate interval to update cooldown timers and sort pills
        setInterval(() => {
            if (faucetRun) {
                const addresses = $("addrsFaucet").value.split(/\n+/).map(s => s.trim()).filter(Boolean);
                createWalletStatusPills(addresses); // Re-render pills with new sort order
            }
        }, 1000);
    </script>
</body>
</html>
